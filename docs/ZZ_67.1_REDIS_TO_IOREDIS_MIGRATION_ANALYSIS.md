# üîÑ PH√ÇN T√çCH CHUY·ªÇN ƒê·ªîI T·ª™ REDIS SANG IOREDIS

## üìã T·ªîNG QUAN

T√†i li·ªáu n√†y ph√¢n t√≠ch chi ti·∫øt vi·ªác chuy·ªÉn ƒë·ªïi t·ª´ th∆∞ vi·ªán `redis` (node-redis) sang `ioredis` trong d·ª± √°n NestJS Ecommerce API.

### üéØ M·ª•c Ti√™u

- Thay th·∫ø th∆∞ vi·ªán `redis` b·∫±ng `ioredis`
- ƒê·∫£m b·∫£o t√≠nh t∆∞∆°ng th√≠ch v·ªõi c√°c module hi·ªán t·∫°i
- T·ªëi ∆∞u h√≥a performance v√† code quality
- Gi·ªØ nguy√™n ch·ª©c nƒÉng hi·ªán t·∫°i

---

## üìä HI·ªÜN TR·∫†NG S·ª¨ D·ª§NG REDIS

### 1. Dependencies Hi·ªán T·∫°i

```json
{
  "dependencies": {
    "redis": "^5.8.2", // ‚ùå S·∫Ω thay th·∫ø
    "ioredis": "^5.7.0", // ‚úÖ ƒê√£ c√≥ s·∫µn
    "@keyv/redis": "^5.1.1", // S·ª≠ d·ª•ng cho CacheModule
    "@socket.io/redis-adapter": "^8.3.0", // Socket.IO adapter
    "@nestjs/bullmq": "^11.0.3", // Queue system
    "bullmq": "^5.58.0" // S·ª≠ d·ª•ng ioredis internally
  }
}
```

### 2. C√°c File S·ª≠ D·ª•ng Redis Library

#### üìÅ File 1: `src/websockets/websocket.adapter.ts`

**Ch·ª©c nƒÉng:** WebSocket adapter cho Socket.IO v·ªõi Redis pub/sub

```typescript
// ‚ùå HI·ªÜN T·∫†I - S·ª≠ d·ª•ng redis
import { createClient } from 'redis'
import { createAdapter } from '@socket.io/redis-adapter'

async connectToRedis(): Promise<void> {
  const pubClient = createClient({ url: envConfig.REDIS_URL })
  const subClient = pubClient.duplicate()

  await Promise.all([pubClient.connect(), subClient.connect()])

  this.adapterConstructor = createAdapter(pubClient, subClient)
}
```

**V·∫•n ƒë·ªÅ:**

- S·ª≠ d·ª•ng `createClient` t·ª´ package `redis`
- C·∫ßn connect() tr∆∞·ªõc khi s·ª≠ d·ª•ng
- `@socket.io/redis-adapter` h·ªó tr·ª£ c·∫£ `redis` v√† `ioredis`

---

#### üìÅ File 2: `src/websockets/services/chat-redis.service.ts`

**Ch·ª©c nƒÉng:** Qu·∫£n l√Ω cache cho chat system (online users, typing indicators, conversations)

```typescript
// ‚ùå HI·ªÜN T·∫†I - S·ª≠ d·ª•ng redis
import { createClient, RedisClientType } from 'redis'

@Injectable()
export class ChatRedisService {
  private readonly redis: RedisClientType

  constructor() {
    this.redis = createClient({ url: envConfig.REDIS_URL })

    this.redis.on('connect', () => {
      this.logger.log('Connected to Redis for chat cache')
    })

    this.redis.on('error', (error) => {
      this.logger.error('Redis connection error:', error)
    })

    this.redis.connect().catch((error) => {
      this.logger.error('Failed to connect to Redis:', error)
    })
  }

  // C√°c methods s·ª≠ d·ª•ng:
  // - get(key)
  // - setEx(key, ttl, value)
  // - del(key)
  // - exists(key)
  // - keys(pattern)
  // - ping()
  // - disconnect()
}
```

**C√°c operations ƒë∆∞·ª£c s·ª≠ d·ª•ng:**

1. `get(key)` - L·∫•y gi√° tr·ªã
2. `setEx(key, ttl, value)` - Set v·ªõi TTL
3. `del(key)` - X√≥a key
4. `exists(key)` - Ki·ªÉm tra key t·ªìn t·∫°i
5. `keys(pattern)` - T√¨m keys theo pattern
6. `ping()` - Health check
7. `disconnect()` - ƒê√≥ng k·∫øt n·ªëi

---

#### üìÅ File 3: `src/app.module.ts`

**Ch·ª©c nƒÉng:** Configuration cho CacheModule v√† BullMQ

```typescript
// ‚úÖ ƒê√É S·ª¨ D·ª§NG IOREDIS (qua @keyv/redis)
import { createKeyv } from '@keyv/redis'

CacheModule.registerAsync({
  isGlobal: true,
  useFactory: () => {
    return {
      stores: [createKeyv(envConfig.REDIS_URL)],
    }
  },
}),

// ‚úÖ BullMQ ƒê√É S·ª¨ D·ª§NG IOREDIS internally
BullModule.forRoot({
  connection: {
    url: envConfig.REDIS_URL,
  },
}),
```

**L∆∞u √Ω:**

- `@keyv/redis` s·ª≠ d·ª•ng `@redis/client` (t·ª´ package `redis`)
- `BullMQ` s·ª≠ d·ª•ng `ioredis` internally
- Kh√¥ng c·∫ßn thay ƒë·ªïi ph·∫ßn n√†y

---

#### üìÅ File 4: `src/main.ts`

**Ch·ª©c nƒÉng:** Bootstrap WebSocket adapter

```typescript
// Kh·ªüi t·∫°o WebSocket adapter v·ªõi Redis
const websocketAdapter = new WebsocketAdapter(app)
await websocketAdapter.connectToRedis()
app.useWebSocketAdapter(websocketAdapter)
```

**L∆∞u √Ω:**

- Ph·ª• thu·ªôc v√†o `websocket.adapter.ts`
- Kh√¥ng c·∫ßn thay ƒë·ªïi tr·ª±c ti·∫øp

---

## üîç SO S√ÅNH REDIS VS IOREDIS

### API Differences

| T√≠nh nƒÉng            | redis (node-redis)             | ioredis                                                    |
| -------------------- | ------------------------------ | ---------------------------------------------------------- |
| **Connection**       | `createClient()` + `connect()` | `new Redis()` - auto connect                               |
| **Event: Connect**   | `'connect'`                    | `'connect'` ho·∫∑c `'ready'`                                 |
| **Event: Error**     | `'error'`                      | `'error'`                                                  |
| **Get**              | `get(key)`                     | `get(key)`                                                 |
| **Set with TTL**     | `setEx(key, ttl, value)`       | `setex(key, ttl, value)` ho·∫∑c `set(key, value, 'EX', ttl)` |
| **Delete**           | `del(key)`                     | `del(key)`                                                 |
| **Exists**           | `exists(key)`                  | `exists(key)`                                              |
| **Keys**             | `keys(pattern)`                | `keys(pattern)`                                            |
| **Ping**             | `ping()`                       | `ping()`                                                   |
| **Disconnect**       | `disconnect()`                 | `disconnect()` ho·∫∑c `quit()`                               |
| **Duplicate**        | `duplicate()`                  | `duplicate()`                                              |
| **Cluster Support**  | Limited                        | ‚úÖ Full support                                            |
| **Sentinel Support** | Limited                        | ‚úÖ Full support                                            |
| **Pipeline**         | ‚úÖ                             | ‚úÖ Better                                                  |
| **Lua Scripts**      | ‚úÖ                             | ‚úÖ Better                                                  |
| **TypeScript**       | Good                           | Excellent                                                  |

### ∆Øu ƒêi·ªÉm c·ªßa IORedis

1. **Performance t·ªët h∆°n** - Optimized cho high throughput
2. **Cluster & Sentinel support** - Production-ready
3. **Better TypeScript support** - Type definitions t·ªët h∆°n
4. **Auto-reconnect** - T·ª± ƒë·ªông k·∫øt n·ªëi l·∫°i
5. **Pipeline & Transaction** - API t·ªët h∆°n
6. **Lua scripting** - D·ªÖ s·ª≠ d·ª•ng h∆°n
7. **Community** - ƒê∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i h∆°n trong NestJS ecosystem

---

## üìù K·∫æ HO·∫†CH MIGRATION

### B∆∞·ªõc 1: C·∫≠p Nh·∫≠t Dependencies

```bash
# Kh√¥ng c·∫ßn c√†i ƒë·∫∑t v√¨ ƒë√£ c√≥ ioredis
# Ch·ªâ c·∫ßn remove redis n·∫øu kh√¥ng c√≤n dependency n√†o kh√°c
pnpm remove redis
```

**L∆∞u √Ω:** Ki·ªÉm tra `@keyv/redis` v√† `@socket.io/redis-adapter` c√≥ ph·ª• thu·ªôc v√†o `redis` kh√¥ng.

### B∆∞·ªõc 2: Migration Files

#### 2.1. File `src/websockets/websocket.adapter.ts`

```typescript
// ‚úÖ SAU - S·ª≠ d·ª•ng ioredis
import Redis from 'ioredis'
import { createAdapter } from '@socket.io/redis-adapter'

async connectToRedis(): Promise<void> {
  const pubClient = new Redis(envConfig.REDIS_URL)
  const subClient = pubClient.duplicate()

  // Kh√¥ng c·∫ßn await connect() - ioredis t·ª± ƒë·ªông connect

  this.adapterConstructor = createAdapter(pubClient, subClient)
}
```

**Thay ƒë·ªïi:**

- `createClient()` ‚Üí `new Redis()`
- B·ªè `await connect()` - ioredis auto-connect
- `duplicate()` ho·∫°t ƒë·ªông t∆∞∆°ng t·ª±

---

#### 2.2. File `src/websockets/services/chat-redis.service.ts`

```typescript
// ‚úÖ SAU - S·ª≠ d·ª•ng ioredis
import Redis from 'ioredis'

@Injectable()
export class ChatRedisService {
  private readonly redis: Redis

  constructor() {
    this.redis = new Redis(envConfig.REDIS_URL, {
      retryStrategy: (times) => {
        const delay = Math.min(times * 50, 2000)
        return delay
      },
      maxRetriesPerRequest: 3,
    })

    this.redis.on('connect', () => {
      this.logger.log('Connected to Redis for chat cache')
    })

    this.redis.on('error', (error) => {
      this.logger.error('Redis connection error:', error)
    })

    // Kh√¥ng c·∫ßn g·ªçi connect() - ioredis t·ª± ƒë·ªông connect
  }

  // Methods mapping:
  async addOnlineUser(userId: number, socketId: string): Promise<void> {
    const userKey = `${this.KEYS.ONLINE_USERS}:${userId}`
    const currentSocketsJson = await this.redis.get(userKey)
    const currentSockets = currentSocketsJson ? JSON.parse(currentSocketsJson) : []

    if (!currentSockets.includes(socketId)) {
      currentSockets.push(socketId)
    }

    // setEx ‚Üí setex (lowercase)
    await this.redis.setex(userKey, 3600, JSON.stringify(currentSockets))
  }

  async healthCheck(): Promise<boolean> {
    try {
      const result = await this.redis.ping()
      return result === 'PONG'
    } catch (error) {
      this.logger.error('Redis health check failed:', error)
      return false
    }
  }

  async disconnect(): Promise<void> {
    try {
      await this.redis.quit() // ho·∫∑c disconnect()
      this.logger.log('Disconnected from Redis')
    } catch (error) {
      this.logger.error('Error disconnecting from Redis:', error)
    }
  }
}
```

**Thay ƒë·ªïi ch√≠nh:**

- `createClient()` ‚Üí `new Redis()`
- `setEx()` ‚Üí `setex()` (lowercase)
- Th√™m retry strategy v√† options
- B·ªè `connect()` call
- `disconnect()` ‚Üí `quit()` (recommended) ho·∫∑c `disconnect()`

---

## üîß CHI TI·∫æT IMPLEMENTATION

### Method Mapping Table

| redis (node-redis)              | ioredis                        | Ghi ch√∫               |
| ------------------------------- | ------------------------------ | --------------------- |
| `createClient({ url })`         | `new Redis(url)`               | Constructor kh√°c nhau |
| `client.connect()`              | Kh√¥ng c·∫ßn                      | Auto-connect          |
| `client.get(key)`               | `redis.get(key)`               | Gi·ªëng nhau            |
| `client.setEx(key, ttl, value)` | `redis.setex(key, ttl, value)` | Lowercase 'ex'        |
| `client.del(key)`               | `redis.del(key)`               | Gi·ªëng nhau            |
| `client.exists(key)`            | `redis.exists(key)`            | Gi·ªëng nhau            |
| `client.keys(pattern)`          | `redis.keys(pattern)`          | Gi·ªëng nhau            |
| `client.ping()`                 | `redis.ping()`                 | Gi·ªëng nhau            |
| `client.disconnect()`           | `redis.quit()`                 | N√™n d√πng quit()       |
| `client.duplicate()`            | `redis.duplicate()`            | Gi·ªëng nhau            |

### Configuration Options

```typescript
// IORedis Configuration
const redis = new Redis(envConfig.REDIS_URL, {
  // Retry strategy
  retryStrategy: (times) => {
    const delay = Math.min(times * 50, 2000)
    return delay
  },

  // Max retries per request
  maxRetriesPerRequest: 3,

  // Enable offline queue
  enableOfflineQueue: true,

  // Connection timeout
  connectTimeout: 10000,

  // Keep alive
  keepAlive: 30000,

  // Lazy connect (n·∫øu mu·ªën manual connect)
  lazyConnect: false,

  // TLS options (n·∫øu c·∫ßn)
  // tls: {},

  // Reconnect on error
  reconnectOnError: (err) => {
    const targetError = 'READONLY'
    if (err.message.includes(targetError)) {
      return true
    }
    return false
  },
})
```

---

## üìã DANH S√ÅCH THAY ƒê·ªîI CHI TI·∫æT

### File 1: `src/websockets/websocket.adapter.ts`

**Thay ƒë·ªïi:**

```typescript
// ‚ùå TR∆Ø·ªöC
import { createClient } from 'redis'

async connectToRedis(): Promise<void> {
  const pubClient = createClient({ url: envConfig.REDIS_URL })
  const subClient = pubClient.duplicate()

  await Promise.all([pubClient.connect(), subClient.connect()])

  this.adapterConstructor = createAdapter(pubClient, subClient)
}
```

```typescript
// ‚úÖ SAU
import Redis from 'ioredis'

async connectToRedis(): Promise<void> {
  const pubClient = new Redis(envConfig.REDIS_URL, {
    retryStrategy: (times) => Math.min(times * 50, 2000),
    maxRetriesPerRequest: 3,
  })

  const subClient = pubClient.duplicate()

  // Kh√¥ng c·∫ßn await connect() - ioredis auto-connect
  // Nh∆∞ng c√≥ th·ªÉ ƒë·ª£i ready event n·∫øu mu·ªën ch·∫Øc ch·∫Øn
  await Promise.all([
    new Promise((resolve) => pubClient.once('ready', resolve)),
    new Promise((resolve) => subClient.once('ready', resolve)),
  ])

  this.adapterConstructor = createAdapter(pubClient, subClient)
}
```

**L√Ω do:**

- `@socket.io/redis-adapter` h·ªó tr·ª£ c·∫£ `redis` v√† `ioredis`
- IORedis c√≥ auto-reconnect t·ªët h∆°n
- Performance t·ªët h∆°n cho pub/sub

---

### File 2: `src/websockets/services/chat-redis.service.ts`

**Thay ƒë·ªïi to√†n b·ªô file:**

```typescript
// ‚úÖ HO√ÄN CH·ªàNH - S·ª≠ d·ª•ng ioredis
import { Injectable, Logger } from '@nestjs/common'
import Redis from 'ioredis'
import envConfig from 'src/shared/config'

@Injectable()
export class ChatRedisService {
  private readonly logger = new Logger(ChatRedisService.name)
  private readonly redis: Redis

  // Redis key prefixes
  private readonly KEYS = {
    ONLINE_USERS: 'chat:online_users',
    USER_SOCKETS: 'chat:user_sockets',
    TYPING_USERS: 'chat:typing',
    USER_CONVERSATIONS: 'chat:user_conversations',
  } as const

  constructor() {
    this.redis = new Redis(envConfig.REDIS_URL, {
      retryStrategy: (times) => {
        const delay = Math.min(times * 50, 2000)
        return delay
      },
      maxRetriesPerRequest: 3,
      enableOfflineQueue: true,
    })

    this.redis.on('connect', () => {
      this.logger.log('Connected to Redis for chat cache')
    })

    this.redis.on('ready', () => {
      this.logger.log('Redis is ready for chat cache')
    })

    this.redis.on('error', (error) => {
      this.logger.error('Redis connection error:', error)
    })

    this.redis.on('close', () => {
      this.logger.warn('Redis connection closed')
    })

    this.redis.on('reconnecting', () => {
      this.logger.log('Reconnecting to Redis...')
    })
  }

  // ===== ONLINE USERS MANAGEMENT =====

  async addOnlineUser(userId: number, socketId: string): Promise<void> {
    try {
      const userKey = `${this.KEYS.ONLINE_USERS}:${userId}`
      const currentSocketsJson = await this.redis.get(userKey)
      const currentSockets = currentSocketsJson ? JSON.parse(currentSocketsJson) : []

      if (!currentSockets.includes(socketId)) {
        currentSockets.push(socketId)
      }

      // setEx ‚Üí setex (lowercase)
      await this.redis.setex(userKey, 3600, JSON.stringify(currentSockets))
    } catch (error) {
      this.logger.error(`Error adding online user ${userId}:`, error)
    }
  }

  async removeOnlineUser(userId: number, socketId: string): Promise<boolean> {
    try {
      const userKey = `${this.KEYS.ONLINE_USERS}:${userId}`
      const currentSocketsJson = await this.redis.get(userKey)

      if (!currentSocketsJson) return false

      const currentSockets = JSON.parse(currentSocketsJson)
      const updatedSockets = currentSockets.filter((id: string) => id !== socketId)

      if (updatedSockets.length === 0) {
        await this.redis.del(userKey)
        return true
      } else {
        await this.redis.setex(userKey, 3600, JSON.stringify(updatedSockets))
        return false
      }
    } catch (error) {
      this.logger.error(`Error removing online user ${userId}:`, error)
      return false
    }
  }

  async isUserOnline(userId: number): Promise<boolean> {
    try {
      const userKey = `${this.KEYS.ONLINE_USERS}:${userId}`
      const exists = await this.redis.exists(userKey)
      return exists === 1
    } catch (error) {
      this.logger.error(`Error checking online status for user ${userId}:`, error)
      return false
    }
  }

  async getOnlineUsers(): Promise<number[]> {
    try {
      const pattern = `${this.KEYS.ONLINE_USERS}:*`
      const keys = await this.redis.keys(pattern)

      return keys
        .map((key) => {
          const userId = key.split(':').pop()
          return parseInt(userId!, 10)
        })
        .filter((id) => !isNaN(id))
    } catch (error) {
      this.logger.error('Error getting online users:', error)
      return []
    }
  }

  async getUserSocketIds(userId: number): Promise<string[]> {
    try {
      const userKey = `${this.KEYS.ONLINE_USERS}:${userId}`
      const socketsJson = await this.redis.get(userKey)
      return socketsJson ? JSON.parse(socketsJson) : []
    } catch (error) {
      this.logger.error(`Error getting socket IDs for user ${userId}:`, error)
      return []
    }
  }

  // ===== SOCKET USER INFO MANAGEMENT =====

  async setSocketUser(socketId: string, userInfo: Record<string, any>): Promise<void> {
    try {
      const socketKey = `${this.KEYS.USER_SOCKETS}:${socketId}`
      await this.redis.setex(socketKey, 3600, JSON.stringify(userInfo))
    } catch (error) {
      this.logger.error(`Error setting socket user info for ${socketId}:`, error)
    }
  }

  async getSocketUser(socketId: string): Promise<Record<string, any> | null> {
    try {
      const socketKey = `${this.KEYS.USER_SOCKETS}:${socketId}`
      const userInfoJson = await this.redis.get(socketKey)
      return userInfoJson ? JSON.parse(userInfoJson) : null
    } catch (error) {
      this.logger.error(`Error getting socket user info for ${socketId}:`, error)
      return null
    }
  }

  async removeSocket(socketId: string): Promise<void> {
    try {
      const socketKey = `${this.KEYS.USER_SOCKETS}:${socketId}`
      await this.redis.del(socketKey)
    } catch (error) {
      this.logger.error(`Error removing socket ${socketId}:`, error)
    }
  }

  // ===== TYPING INDICATORS MANAGEMENT =====

  async setUserTyping(conversationId: string, userId: number, expiresInSeconds: number = 10): Promise<void> {
    try {
      const typingKey = `${this.KEYS.TYPING_USERS}:${conversationId}`
      const currentTypingJson = await this.redis.get(typingKey)
      const currentTyping = currentTypingJson ? JSON.parse(currentTypingJson) : []

      if (!currentTyping.includes(userId)) {
        currentTyping.push(userId)
      }

      await this.redis.setex(typingKey, expiresInSeconds, JSON.stringify(currentTyping))
    } catch (error) {
      this.logger.error(`Error setting typing for user ${userId} in conversation ${conversationId}:`, error)
    }
  }

  async removeUserTyping(conversationId: string, userId: number): Promise<void> {
    try {
      const typingKey = `${this.KEYS.TYPING_USERS}:${conversationId}`
      const currentTypingJson = await this.redis.get(typingKey)

      if (!currentTypingJson) return

      const currentTyping = JSON.parse(currentTypingJson)
      const updatedTyping = currentTyping.filter((id: number) => id !== userId)

      if (updatedTyping.length === 0) {
        await this.redis.del(typingKey)
      } else {
        await this.redis.setex(typingKey, 10, JSON.stringify(updatedTyping))
      }
    } catch (error) {
      this.logger.error(`Error removing typing for user ${userId} in conversation ${conversationId}:`, error)
    }
  }

  async getTypingUsers(conversationId: string): Promise<number[]> {
    try {
      const typingKey = `${this.KEYS.TYPING_USERS}:${conversationId}`
      const typingJson = await this.redis.get(typingKey)
      return typingJson ? JSON.parse(typingJson) : []
    } catch (error) {
      this.logger.error(`Error getting typing users for conversation ${conversationId}:`, error)
      return []
    }
  }

  async removeUserFromAllTyping(userId: number): Promise<void> {
    try {
      const pattern = `${this.KEYS.TYPING_USERS}:*`
      const keys = await this.redis.keys(pattern)

      for (const key of keys) {
        const conversationId = key.split(':').pop()!
        await this.removeUserTyping(conversationId, userId)
      }
    } catch (error) {
      this.logger.error(`Error removing user ${userId} from all typing:`, error)
    }
  }

  // ===== USER CONVERSATIONS CACHE =====

  async cacheUserConversations(userId: number, conversationIds: string[]): Promise<void> {
    try {
      const userConversationsKey = `${this.KEYS.USER_CONVERSATIONS}:${userId}`

      if (conversationIds.length === 0) {
        await this.redis.del(userConversationsKey)
        return
      }

      await this.redis.setex(userConversationsKey, 300, JSON.stringify(conversationIds))
    } catch (error) {
      this.logger.error(`Error caching conversations for user ${userId}:`, error)
    }
  }

  async getCachedUserConversations(userId: number): Promise<string[] | null> {
    try {
      const userConversationsKey = `${this.KEYS.USER_CONVERSATIONS}:${userId}`
      const conversationsJson = await this.redis.get(userConversationsKey)
      return conversationsJson ? JSON.parse(conversationsJson) : null
    } catch (error) {
      this.logger.error(`Error getting cached conversations for user ${userId}:`, error)
      return null
    }
  }

  async invalidateUserConversations(userId: number): Promise<void> {
    try {
      const userConversationsKey = `${this.KEYS.USER_CONVERSATIONS}:${userId}`
      await this.redis.del(userConversationsKey)
    } catch (error) {
      this.logger.error(`Error invalidating conversations cache for user ${userId}:`, error)
    }
  }

  // ===== UTILITY METHODS =====

  cleanup(): void {
    try {
      this.logger.debug('Redis cleanup completed')
    } catch (error) {
      this.logger.error('Error during Redis cleanup:', error)
    }
  }

  async healthCheck(): Promise<boolean> {
    try {
      const result = await this.redis.ping()
      return result === 'PONG'
    } catch (error) {
      this.logger.error('Redis health check failed:', error)
      return false
    }
  }

  async disconnect(): Promise<void> {
    try {
      await this.redis.quit() // Graceful shutdown
      this.logger.log('Disconnected from Redis')
    } catch (error) {
      this.logger.error('Error disconnecting from Redis:', error)
    }
  }
}
```

**Thay ƒë·ªïi ch√≠nh:**

1. `import { createClient, RedisClientType } from 'redis'` ‚Üí `import Redis from 'ioredis'`
2. `private readonly redis: RedisClientType` ‚Üí `private readonly redis: Redis`
3. `createClient({ url })` ‚Üí `new Redis(url, options)`
4. B·ªè `connect()` call
5. `setEx()` ‚Üí `setex()` (t·∫•t c·∫£ c√°c ch·ªó)
6. `disconnect()` ‚Üí `quit()`
7. Th√™m event listeners: `ready`, `close`, `reconnecting`
8. Th√™m retry strategy v√† options

---
